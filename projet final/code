import time
import board
import usb_cdc
import random
from adafruit_neotrellis.neotrellis import NeoTrellis
from adafruit_neotrellis.multitrellis import MultiTrellis


uart = usb_cdc.data if usb_cdc.data else None  # Evite le None que je sais pas pourquoi c'est là

# Temps d'attente avant de passer en mode autonome
TIMEOUT_USB = 3

def detect_mode():
    """Détecte si la Feather est branchée à un PC ou juste à l’alimentation."""
    if not uart:  # Si usb_cdc.data est None, pas de mode 1v1
        return "PVE"

    start_time = time.monotonic()
    while time.monotonic() - start_time < TIMEOUT_USB:
        if uart.in_waiting:  # Si on reçoit une donnée, on est connecté au PC
            return "1v1"

    return "PVE"  # Si rien reçu après le timeout, mode autonome

# Détection au démarrage
mode = detect_mode()
print(f"Mode détecté: {mode}")

if mode == "1v1":
    print("Mode 1v1 activé (PC/raspberry connecté)")
    uart.write(b"MODE 1v1\n")
else:
    print("Mode PVE activé (aucune connexion USB)")


# Init du I2C
i2c_bus = board.I2C()

# Modules NeoTrellis
trelli = [
    [NeoTrellis(i2c_bus, False, addr=0x2E), NeoTrellis(i2c_bus, False, addr=0x2F)],
    [NeoTrellis(i2c_bus, False, addr=0x30), NeoTrellis(i2c_bus, False, addr=0x31)],
]
trellis = MultiTrellis(trelli)  # Gestion pour le 8x8

# Couleurs
OFF = (0, 0, 0)
BLUE = (0, 0, 255)
CYAN = (0, 255, 255)
MAGENTA = (255, 0, 255)
GREEN = (0, 255, 0)
RED = (255, 0, 0)

class TrellisManager:
    def __init__(self, trellis):
        self.trellis = trellis
        self.led_status = [[OFF for i in range(8)] for i in range(8)]  # Stockage de l'état des LEDs dans une matrice
        self.bateaux = []  # Liste des bateaux avec leurs positions
        self.bateau_en_cours = []  # Positions du bateau en cours de placement
        self.taille_bateau = 2  # Taille initiale du bateau (commence par 2)
        self.placement_en_cours = False  # Indicateur si on est en train de placer un bateau
        self.ordre_bateaux = [2, 3, 4]  # Ordre des tailles des bateaux à placer
        self.bateau_index = 0  # Indicateur de quel bateau on est en train de placer
        
    def get_led_id(self, x, y):
        """
        Convertit les coord en un ID de la LED
        coord: (x,y)
        ID: (0-63)
        """
        return y * 8 + x

    def get_led_coordinates(self, led_id):
        """
        Convertit un ID LED en coordonnées
        coord: (x,y)
        ID: (0-63)
        """
        return led_id % 8, led_id // 8

    def set_led(self, x, y, color):
        """
        Change la couleur d'une LED et met à jour son état
        coord: (x,y)
        color: obvious
        """
        self.led_status[y][x] = color
        self.trellis.color(x, y, color)

    def get_led_status(self, x, y):
        """
        Récupère l'état actuel d'une LED d'après ses coord
        coord: (x,y)
        """
        return self.led_status[y][x]
        
    def initialize_board(self, step: str):
        """
        Initialisation des LEDs avec un effet dégradé, miam miam
        """
        if step == "menu":
            couleur_gradient = 5
        else:  # Current else : "init"
            couleur_gradient = 32

        for y in range(8):
            for x in range(8):
                self.trellis.activate_key(x, y, NeoTrellis.EDGE_RISING)
                self.trellis.set_callback(x, y, self.handle_button_test)  # associe la fonction handle quand le (x,y) est cliqué

                # Applique un dégradé
                gradient_color = (x * couleur_gradient, y * couleur_gradient, 150)
                self.set_led(x, y, gradient_color)
                time.sleep(0.01)

        # Éteint toutes les LEDs après l'effet de démarrage
        time.sleep(0.05)
        for y in range(8):
            for x in range(8):
                self.set_led(x, y, OFF)
                time.sleep(0.01)

    def benchmark(self, x, y):
        """Benchmark temp pour mapper le board"""
        if self.get_led_status(x, y) != OFF:
            self.set_led(x, y, OFF)

        self.set_led(x, y, MAGENTA)

    def handle_menu(self, x, y, edge):
        """
        Gère le choix du menu en fonction du bouton pressé
        """
        if edge == NeoTrellis.EDGE_RISING:
            if (x, y) in [(1, 1), (1, 2)]:  # Si on appuie sur la partie "Solo"
                self.menu_type = 'Solo'
                self.initialize_board("menu")
                self.solo_start()
            elif (x, y) in [(5, 1), (5, 2), (6, 1), (6, 2)]:  # Si on appuie sur "Duo"
                self.menu_type = 'Duo'
            print(f"Mode sélectionné : {self.menu_type}")

    def placer_bateaux_bot(self):
        """
        Place aléatoirement 3 bateaux sur la grille.
        Retourne une liste de tuples représentant avec positions des bateaux.
        """
        grille = [[0] * 8 for n in range(8)]  # Grille vide 8x8 (0 = libre ; 1 = occupé)
        tailles_bateaux = [4, 3, 2]  # (Grand, Moyen, Petit)
        bateaux_places = []  # Liste des bateaux avec leurs positions

        for taille in tailles_bateaux:
            IsBateau_bot_placed = False

            while not IsBateau_bot_placed:
                x = random.randint(0, 7)
                y = random.randint(0, 7)
                direction = random.choice(["H", "V"])  # Horizontal ou Vertical en gros

                # Vérifier si le bateau peut être placé
                positions = []
                if direction == "H" and x + taille <= 8:  # Horizontal touche t il le bord ?
                    for i in range(taille):
                        positions.append((x + i, y))  # Pose horizontal
                elif direction == "V" and y + taille <= 8:  # Vertical, même chose
                    for i in range(taille):
                        positions.append((x, y + i))  # Pose vertical

                if not positions:  # si le bateau depasse du plateau on retry
                    continue

                IsBateau_bot_placable = True
                for x, y in positions:
                    if grille[x][y] == 1:  # déjà occupé
                        IsBateau_bot_placable = False
                        break
                if IsBateau_bot_placable:
                    for x, y in positions:
                        grille[x][y] = 1
                    bateaux_places.append(positions)  # enregistre les coordonnées valides
                    IsBateau_bot_placed = True

        return bateaux_places

    def solo_start(self):
        bots_bateaux = self.placer_bateaux_bot()
        for bateau in bots_bateaux:
            print(bateau)  # Affiche les coordonnées des bateaux choisis par le bot

    def handle_placement_bateau(self, x, y, edge):
        """
        Gère les appuis sur les boutons pour placer un bateau.
        coord: (x,y)
        edge: RISING ou FALLING
        """
        if edge == NeoTrellis.EDGE_RISING:  # Si le bouton vient de remonter
            # Si on commence un bateau (taille 2 initiale)
            if not self.placement_en_cours:
                if self.get_led_status(x, y) == OFF:
                    self.set_led(x, y, GREEN)
                    self.bateau_en_cours.append((x, y))
                    self.placement_en_cours = True
                    print(f"Bateau de taille {self.taille_bateau} commence à ({x}, {y})")
            else:
                # Vérifier si la case est adjacente à une autre partie du bateau
                if self.est_adjacent(x, y):
                    if self.get_led_status(x, y) == OFF:  # Si la case est libre
                        self.set_led(x, y, GREEN)
                        self.bateau_en_cours.append((x, y))
                        print(f"Ajout de la case ({x}, {y}) au bateau")
                    else:
                        print(f"Case ({x}, {y}) déjà occupée, essayer une autre")

                # Si le bateau atteint la taille souhaitée, on termine le placement
                if len(self.bateau_en_cours) == self.taille_bateau:
                    print(f"Bateau complet à {self.bateau_en_cours}")
                    self.placer_bateau_sur_grille(self.bateau_en_cours)
                    self.bateau_en_cours = []  # Réinitialiser
                    self.placement_en_cours = False  # Réinitialiser le flag

                    # Passer au bateau suivant
                    self.bateau_index += 1
                    if self.bateau_index < len(self.ordre_bateaux):
                        self.taille_bateau = self.ordre_bateaux[self.bateau_index]  # Prochaine taille
                        print(f"Prochain bateau de taille {self.taille_bateau}")
                    else:
                        print("Tous les bateaux sont placés.")

    def est_adjacent(self, x, y):
        """Vérifie si la case (x, y) est adjacente à une des cases du bateau en cours"""
        for (bx, by) in self.bateau_en_cours:
            if (abs(bx - x) == 1 and by == y) or (abs(by - y) == 1 and bx == x):
                return True
        return False

    def placer_bateau_sur_grille(self, bateau_positions):
        """Place un bateau sur la grille en mettant à jour la grille"""
        for (x, y) in bateau_positions:
            self.grille[x][y] = 1  # Marquer la position comme occupée
        self.bateaux.append(bateau_positions)  # Ajouter le bateau à la liste

    def menu(self):
        """
        Set les leds et bouttons du menu en fonction du type de menu
        solo: I
        duo: I et II (sur le menu)
        """
        leds_ = [(1, 1), (1, 2), (5, 1), (5, 2), (6, 1), (6, 2)]  # Boutons du menu
        if mode == 'PVE':
            for i in range(2):
                self.set_led(leds_[i][0], leds_[i][1], BLUE)
                self.trellis.activate_key(leds_[i][0], leds_[i][1], NeoTrellis.EDGE_RISING)
                self.trellis.set_callback(leds_[i][0], leds_[i][1], self.handle_menu)
            for n in range(2, 6):
                self.set_led(leds_[n][0], leds_[n][1], RED)  # Pas dispo
        else:
            for i in range(6):
                self.set_led(leds_[i][0], leds_[i][1], BLUE)
                self.trellis.activate_key(leds_[i][0], leds_[i][1], NeoTrellis.EDGE_RISING)
                self.trellis.set_callback(leds_[i][0], leds_[i][1], self.handle_menu)

# Création et initialisation du gestionnaire
manager = TrellisManager(trellis)
manager.initialize_board("init")
manager.menu()

# Boucle principale
while True:
    trellis.sync()  # Met à jour les événements des boutons
    time.sleep(0.01)
